# Amazon EKS Anywhere #compute #eks #eksanywhere
collapsed:: true
	- Create an operate K8S clusters created outside AWS
	- Leverage the AWS EKS Distribution
		- Reduce support cost and avoid maintaing redundant third party tools
	- Install using EKS Anywhere Installer
	- Optionally use the EKS Connector to connect EKS Anywhere clusters to AWS
		- Fully Connected & Partially Disconnected -> leverage the managamente on EKS console
		- Fully Disconnected -> **MUST** install the EKS Distro and leverage open-source tools to manage your clusters
- # AWS Lambda #compute #lambda #serverless
  collapsed:: true
	- **Integrations** -> API Gateway, Kinesis, DynamoDB, AWS IoT, AWS S3, EventBridge, CloudWatch Logs, AWS SNS, Cognito, SQS
		- Examples
			- S3 event notification as a trigger of the Lambda
			- Serverless CRON job using EventBridge trigger
	- **Languages** -> Node.js, Python, JAVA, C# (.NET, Powershell), Ruby, Custom Runtime API (community supported, Rust or Golang)
		- Lambda Container Image, so the container **MUST** implement the Lambda Runtime API
			- ECS / Fargate is preferred for running Docker images
	- **Compute specifications**
		- RAM -> 128MB to 10GB
		- CPU -> linked to RAM, it cannot be set manually
		- Execution timeout -> up to 15 minutes
		- /tmp storage -> 10GB
		- Deployment Package size -> 50MB (zipped), 250MB (unzipped) including layers
		- Concurrent Executions -> 1000 (soft limit)
			- You can set a reserved concurrency (hard limit) to ensure a minimum capacity for a invoker
			- Each invocation over the the concurrency limit will trigger a **Throttle**
				- Throttle -> retry the request
			- Can request a quota increase in AWS Service Quotas
		- Container Image Size -> 10GB
		- Invocation Payload -> 6MB (sync), 256KB (async)
	- **CodeDeploy deployment integration**
	  collapsed:: true
		- Automate traffic shift for Lambda aliases
		- Feature is integrated withing the SAM framework
		- **Linear** -> grow traffic every N minutes until 100%
		- **Canary** -> try X%, then 100%
		- **AllAtOnce** -> immediate 100%
		- Can create Pre & Post Traffic hooks to check the health of the Lambda function
	- **Logging, Monitoring and Tracing**
	  collapsed:: true
		- CloudWatch Logs and CloudWatch Metrics
		- X-Ray -> trace invocations. You need to enable it in Lambda config. Use AWS SDK in code to use its tracing mechanism
			- **Ensure Lambda Function has correct IAM Execution Role**
	- **Lambda in a VPC**
	  collapsed:: true
		- By default, Lambda is deployed on public internet
		- If you add the Lambda in a VPC (private subnet)
			- You can connect to private subnet resources (RDS)
			- You need to deploy VPC endpoints to reach other services privately, such as DynamoDB, S3,...
			- **To reach the Internet, configure a NAT and a IGW**
		- If you deploy the lambda in the public subnet, Lambda won't have Internet access
		- Lambda - CloudWatch Logs integrations works even without the endpoint or NAT Gateway
		- ## **Fixed Public IP for external communications** #sa #lambda
			- Use a Lambda in a VPC and assign to the function an *Elastic Network Interface (ENI)*. Also configure a Fixed Elastic IP to the NATGW
	- **Synchronous Invocations**
	  collapsed:: true
		- CLI, SDK, API Gateway invokations
		- Results is returned right away, error handling **MUST** happen client side
	- **Asynchronous Invocations**
	  collapsed:: true
		- S3, SNS, SQS, Amazon EventBridge
		- Lambda attempts to retry on errors (3 tries in total)
		- Make sure the processing is idempotent (in case of retries)
		- Define a *dead-letter queue (DLQ)* for failed processing
	- **Architecture Discussion**
	  collapsed:: true
		- S3 bucket -> SNS topic -> Lambda function
			- Starts immediately, parallel executions if there are a lot of event (higher concurrency)
			- Adding a SQS queue between SNS and Lambda adds a little delay, configuring a *batched execution* of the events
- # Amazon Elastic Load Balancers (ELB) #compute #elb
  collapsed:: true
	- Overall, it's recommended to use the newer LBs as they provide more features
	- Some LBs can be setup as internal or external
	- **Cross-Zone Load Balancing**
	  collapsed:: true
		- With this feature: Each LB instance distributes evenly across all registered instances in all AZ
		- Without this feature: Request are distributed in the instances of the node of the ELB
	- **Sticky Sessions (Session Affinity)**
	  collapsed:: true
		- It is possible to implement stickiness so that the same client is always redirected to the same instance behind a load balancer
		- This works only for CLB and ALB (layer 7 feature)
		- The **cookie** used for stickiness has an expiration date you control
		- Use case
			- Make sure the user doesn't lose his session data
			- Enabling stickiness may bring unbalance to the load over the backend EC2 instances
	- **Request Routing Algorithms**
	  collapsed:: true
		- *Least Outstanding Requests*
			- The next instance to receive the request is the instance that has the lowest number of pending/unfinished requests
			- Works with ALB and CLB (HTTP/HTTPS)
		- *Round Robin*
			- Equally choose the targets from the target group
			- Works with ALB and CLB (TCP)
		- *Flow Hash*
			- Selects a target based on the protocol, source/dest IP address/port, and TCP sequence number
			- Each TCP/UDP connection is routed to a single target for the life of the connection
			- Works with NLB
	- 4 kinds of managed Load Balancers
	  collapsed:: true
		- **Classic Load Balancer (CLB, 2009)**
		  collapsed:: true
			- HTTP/S, TCP, SSL (secure TCP) (layer 7)
			- Health Checks ca be HTTP or TCP based including with SSL
			- Supports only one SSL certificate
				- Can use multiple CLB if you want distinct SSL certificates
				- The SSL certificate can have many *Subject Alternative Name (SAN)*, but the SSL certificate **MUST** be changed anytime a SAN is added/modified/removed.
					- **Better to use ALB with SNI if possible**
			- TCP -> TCP passes all the traffic to the EC2 instance
				- Only way to use 2-way SSL authentication
			- **Cross-Zone Load Balancing**
				- Disabled by default
				- No charges for inter AZ data if enabled
		- **Application Load Balancer (ALB, 2016)**
		  collapsed:: true
			- HTTP/S, WebSocket (layer 7)
			- ~400ms latency
			- Load balancing to multiple HTTP apps accross machines
			- **Target Groups**
				- EC2 instances (can be managed by an ASG), ECS tasks (managed by ECS), Lambda functions (HTTP requests is translated into a JSON event), IP addresses (**MUST** be private)
				- ALB can route to multiple target groups
				- Health check are at the target group level
			- Load balancing to multiple apps on the same machine (ex: containers) - great fit with ECS, has dynamic port mapping
			- Support redirects (HTTP -> HTTPS)
			- Routing rules for path, headers, query strings
			- **Cross-Zone Load Balancing**
				- Always on and cannot be disabled
				- No charges for inter AZ data if enabled
		- **Network Load Balancer (NLB, 2017)**
		  collapsed:: true
			- TCP, TLS (secure TCP), UDP (layer 4)
			- Handle millions of requests per second, less latency (~100ms)
				- Used for extreme performance, TCP or UDP traffic
			- NLB has one static IP per AZ, and supports assigning Elastic IP
			- **Not included in the AWS free tier**
			- **Target Groups**
				- EC2 instances, IP Addresses, **ALB** (both NLB and ALB features)
			- **Zonal DNS Name**
				- Resolving regional NLB DNS name returns the IP address for all NLB nodes in all enabled AZs
				- If you add the AZ name (ex: us-east-1a) as a subdomain of the NLB DNS name, you can resolve the IP address of each node separately
				- Used to minimize latency and data transfer costs
					- You need to implement app specific logic
			- **Cross-Zone Load Balancing**
				- Disabled by default
				- You pay charges for inter AZ data if enabled
		- **Gateway Load Balancer (GWLB, 2020)**
		  collapsed:: true
			- IP protocol (layer 3)
			- Deploy, scale and manage a fleet of third party network virtual appliances in AWS
				- FWs, Intrusion Detection and Prevetion Systems, Deep Packet Inspection Systems, payload manipulation...
			- Combines **Transport Network Gateway** (single entry/exit for all traffic) and **Load Balancing**
			- Uses the [GENEVE](https://www.rfc-editor.org/rfc/rfc8926) protocol on port 6081
			- **Target groups**
				- EC2 instances
				- IP Address - **MUST** be private IPs
			- **Cross-Zone Load Balancing**
				- Disabled by default
				- You pay charges for inter AZ data if enabled
- # API Gateway #compute #apigateway
  collapsed:: true
	- Helps expose Lambda, HTTP & AWS Services as an API
	- **Features** -> APi versioning, authorization, traffic management (API keys, throttles), CORS, OpenAPI specification, scalability, serverless, request/response transformations
	- **Limits to know**
	  collapsed:: true
		- *29 seconds timeout* -> careful if you use with Lambda. If Lambda take too much time to response to API Gateway, it just timeout
		- *10MB max payload size*
	- **Deployment Stages**
	  collapsed:: true
		- API changes are deployed to Stages (as many as you want)
		- Use the naming you like for stages (for example, environment names)
		- Stages can be rolled back as a history of deployments is kept
	- **Integrations**
	  collapsed:: true
		- HTTP
			- Internal HTTP API on-prem, ALB
			- Add rate-limits, caching, user auth, API Keys, etc.
		- Lambda Function
			- Invoke Lambda function
			- Easy way to expose REST API backed
		- AWS Service
			- Expose any AWS API through the API Gateway
			- Add rate-limits, caching, user auth, API Keys, etc.
	- ## Solution Architecture: API Gateway in front of S3 #apigateway #s3 #sa
	  collapsed:: true
		- **YOU WILL BE IMPACTED BY THE 10MB PAYLOAD SIZE LIMIT**
		- It is not the perfect solution but it can be a possible one
		- Better solution -> use Lambda to generate pre-signed URL and return it to the client application to upload to S3 directly
	- **Endpoint Types**
	  collapsed:: true
		- *Edge-Optimized (default)* -> global clients
			- Uses CloudFront Edge locations
			- API Gateway still lives in only one region
			- ACM certificate for the custom domain name **MUST** be requested or imported in the us-east-1 region
		- *Regional*
			- For clients within the same region
			- Could be manually combined with CloudFront (caching strategies and the distribution)
		- *Private*
			- Can only be accessed from your VPC using an interface VPC endpoint (ENI)
			- Use a resource policy to define acces
	- **Caching**
	  collapsed:: true
		- Reduce calls number made to the backend
		- By default, cache TTL is 300 (0-3600)
		- They are defined per stage
		- It is possible to override cache settings per method
		- Able to flush the entire cache immediately
		- Cache encryption option
		- Cache capacity is between 0.5-237GB
	- **Errors**
	  collapsed:: true
		- 4xx -> Client errors. 400, 403 (WAF filtered), 429 (Quota exceeded, throttling)
		- 5xx -> Server errors. 502 (incompatible output returned from a Lambda proxy integration backend), 503, 504 (29 seconds timeout)
	- **Security**
	  collapsed:: true
		- Load SSL certs and use Route53 to define a CNAME
		- Resource Policy (~S3 bucket policy)
			- Control who can access the API
			- Users from AWS accounts, IP or CIDR blocks, VPC or VPC endpoints
		- IAM Execution Roles for API Gateway at the API level
			- To invoke a Lambda Function, an AWS service...
		- *Cross-origin resource sharing (CORS)*
			- Browser based security
			- Control which domains can call your API
	- **Authentication**
	  collapsed:: true
		- IAM bases access
			- Provide access within your own infrastructure
			- Pass IAM credentials in headers through Sig V4
		- Lambda Authorizer
			- Integrate OAuth / SAML / third party auth methods
		- Cognito User Pools
			- Client authenticates with Cognito, retrieving a token
			- Client passes the token to API Gateway
			- API Gateway verifies the token
	- **Logging, Monitoring & Tracing**
	  collapsed:: true
		- CloudWatch Logs
			- Enabled at the Stage level (with Log Level)
			- Can log full requests / responses data
			- Can send API Gateway Access Logs
			- Can send logs directly into Kinesis Data Firehose
		- CloudWatch Metrics
			- Metrics are by stage, possibility to enabled detailed metrics
			- E.g.: *IntegrationLatency*, *Latency*, *CacheHitCount*, *CacheMissCount*
		- X-Ray
		  collapsed:: true
			- X-Ray API Gateway + AWS Lambda to get the full picture
	- **Usage Plans & API Keys**
	  collapsed:: true
		- If you want to make an API available as an offering to your customers
		- **Usage plan**
			- Who can access one or more deployed API stages and methods
			- How much and how fast they can acces them
			- Uses API keys to identify API clients and meter access
			- Configure throttling limits and quota limits that are enforced on individual client
		- **API Keys**
			- Alphanumeric string values to distribute to your customers
			- Can use with usage plans to control access
			- Throttling limits are applied to the API keys
			- Quotas limits is the overall number of maximum requests
	- **WebSocket API**
	  collapsed:: true
		- 2-way interactive communication between a user's browser and a server
		- Server can push information to the client
		- This enables **stateful** app use cases
			- Usually used in real-time apps
		- Works with AWS Services (Lambda, DynamoDB) or HTTP endpoints
		- **@connections** used for replies to clients
	- **Private APIs**
	  collapsed:: true
		- Can only be accessed from your VPC by using VPC Interface Endpoint
		- Each VPC Interface Endpoint can be used to access multiple Private APIs
		- API Gateway Resource Policy
			- Allow or deny access to API from selected VPCs and VPC endpointsw, including across AWS accounts
				- *aws:SourceVcp* and *aws:SourceVcpe*
- # AWS AppSync #compute #appsync
  collapsed:: true
	- Managed service that use [GraphQL](https://graphql.org/)
	  collapsed:: true
		- Makes easier for apps to get exactly the data they need
		- GraphQL schema (how to format data) and resolver (where to get data)
	- Retrieve data in real-time with WebSocket or *Message Queuing Telemetry Transport (MQTT)* on WebSocket
	- For mobile apps -> local data access & data sync
	- **Cognito integration**
	  collapsed:: true
		- Perform authentication on Cognito users based on the groups they belong to
		- In the GraphQL schema, you can specify the security for Cognito groups
- # AWS Global Accelerator #compute #networking #globalaccelerator
  collapsed:: true
	- Leverage the AWS internal network to route your app
	- 2 Anycast IPs are created for your app
	  collapsed:: true
		- Send traffic directly to Edge Locations
		- Edge Locations send the traffic to your app
	- Works with Elastic IP, EC2 instances, ALB, NLB, public or private
	- Supports Client IP Address Preservation except EIPs endpoints
	- **Performance**
	  collapsed:: true
		- Intelligent routing to lowest latency and fast regional fail-over
		- No issue with client cache
		- Internal AWS network
	- **Health Checks**
	  collapsed:: true
		- Fail-over less than 1 minute for unhealthy
		- Great for disaster recovery
	- **Security**
	  collapsed:: true
		- Only 2 external IP need to be whitelisted
		- DDoS protection using AWS Shield
	- **vs. CloudFront**
	  collapsed:: true
		- **CloudFront**
			- Improves performance for both cacheable content
			- Dynamic content
			- Content is served at the edge
		- **Global Accelerator**
			- Improves performance for a wide range of apps over TCP or UDP
				- Proxying packets at the edge to apps running in multiple AWS Regions
				- Good fit for non-HTTP use cases
				- Good for HTTP use cases that require static IP addresses and deterministic, fast regional fail-over
- # AWS Outposts #compute #outposts
  collapsed:: true
	- *Hybrid Cloud*: businesses that keep an on-prem infrastructure alongside a cloud infrastructure
	- Server racks that offers the same AWS infrastructure, services, APIs & tools to build your own applications on-prem just as in the cloud
	  collapsed:: true
		- AWS will setup and manage **"Outposts Racks"**
		- You are responsible for the  **"Outposts Racks"** physical security
	- **Benefits**
	  collapsed:: true
		- Low-latency access to on-prem systems
		- Loccal data processing
		- Data residency
		- Easier migration from on-prem to the cloud
		- Fully managed services
		- Multiple services are compatible with Outposts
			- S3 on AWS Outposts
				- Use S3 APIs to store and retrieve data locally AWS Outposts
				- Default encryption using SSE-S3
				- Reduce data transfers to AWS Regions
				- Keeping data close to on-prem apps
				- Use it  with a S3 Access Point or with AWS DataSync
- # AWS WaveLength #compute #wavelength
  collapsed:: true
	- Infrastructure deployments embedded withing the telecommunications providers' datacenters at the edge of the 5G networks
	  collapsed:: true
		- Brings AWS services to the edge of the 5G networks
		- Example: EC2, EBS, VPC
	- **Use case** -> Ultra-low latency apps through 5G networks
	  collapsed:: true
		- Smart Cities, ML-assisted diagnostics, Connected Vehicles, Interactive Live Video Streams, AR/VR, Real-time Gaming,...
	- Traffic doesn't leave the *Communication Service Provider's (CSP)* network
	- High-bandwidth and secure connection to the parent AWS Region
	- No additional charges or service agreements
- # AWS Local Zones #compute #localzones
  collapsed:: true
	- Places AWS services closer to end users to run latency-sensitive apps
	- Extend your VPC to more locations, for example:
	  collapsed:: true
		- North Virginia could be extended to Boston, Miami, Chicago, Dallas, Houston, Miami and so on.
	- You need to enable specific Local Zones.
	  collapsed:: true
		- Create new resources (subnet, routes, etc.) associated to the Local Zone
- # AWS Route53 #compute #networking #dns #route53
  collapsed:: true
	- **Record types**
	  collapsed:: true
		- **A** -> maps a hostname to IPv4
		- **AAAA** -> maps a hostname to IPv6
		- **CNAME** -> maps a hostname to another hostname
			- **ONLY FOR NON ROOT DOMAIN**
			- **vs. Alias**
				- **THIS WORKS FOR ROOT DOMAIN AND NON ROOT DOMAIN**
				- Free of charge, native health check
				- Targets -> ELBs, CloudFront distributions, S3 Static Websites, VPC Interface Endpoints, Global Accelerator accelerator, Route53 record in the same hosted zone, Elastic Beanstalk environments
					- You cannot set an ALIAS record for an EC2 DNS name
		- **NS** -> Name Servers for the Hosted Zone
	- **Records Time To Live (TTL)**
	  collapsed:: true
		- High TTL -> less traffic/costs on Route53, possibly outdated records
		- Low TTL ->more traffic/costs on Route53, records are outdated for less time, easy to change records
		- **TTL IS MANDATORY FOR EACH DNS RECORD, EXCEPT FOR ALIAS RECORDS**
	- **Routing Policies**
	  collapsed:: true
		- **Simple**
			- Typically, route traffic to a single resource
				- You can specify multiple values in the same record. A random record will be chosen by the client
			- Cannot be associated with Health Checks
		- **Weighted**
			- Control the % of the request that go to each specific resource
			- Can be associated with Health Checks
			- Use cases -> load balancing between regions, testing new app versions...
		- **Latency-based**
			- Redirect to the resource that has the least latency close to us
			- Latency is based on traffic between users and AWS regions
			- Can be associated with Health Checks (has a fail-over capability)
		- **Fail-over (Active-Passive)**
			- Based on a health check for the primary destination
		- **Geolocation**
			- **DIFFERENT FROM LATENCY-BASED**
				- This routing is based on user location specifically
				- Specify location by continent, country or by US state
					- If there's overlapping, most precise location selected
				- You should create a "Default" record in case there's no match on location
			- Can be associated with Health Checks
			- Use cases: website localization, restrict content distribution, load balancing...
		- **Geoproximity**
			- Route traffic to your resources based on the geographic location of users and resources
			- Capability to shift more traffic to resources based on the defined bias
				- To expand (positive values, 1 to 99) or to shrink (negative values, -1 to -99)
			- Resources can be AWS Resources (specify AWS Region) or non-AWS resources (specify latitude and longitude)
			- You **MUST** use Route53 **Traffic Flow** to use this feature
				- Visual editor to manage complex routing decision trees
				- Configuration can be saved as **Traffic Flow Policy**
					- Can be applied to different Route53 Hosted Zones (different domain names)
					- Supports versioning
		- **Multi-Value**
			- Use when routing traffic to multiple resources
			- Route53 return multiple values/resources
			- Can be associated with Health Checks
				- Return only values for healthy resources
			- Up to 8 healthy records are returned for each Multi-Value query
			- **Is not a substitute for having an ELB**
		- **IP-based routing**
			- Routing is based on clients' IP addresses
				- Provide a list of CIDRs for your clients and corresponding endpoints/locations
			- **Use cases**: performance optimization, reduce network costs
				- **Examples**:  route end users from a particular ISP to a specific endpoint
	- **Hosted Zones**
	  collapsed:: true
		- Container for records that define how to route traffic to a domain and its subdomains
			- **Public Hosted Zones** -> route traffic to Internet
				- Publicy accessible
			- **Private Hosted Zones** -> route traffic within one or more VPCs
				- Accessed within a VPC
				- **MUST** enabled *enableDnsHostnames* and *enableDnsSupport* checks
	- **DNS Security Extensions (DNSSEC)**
	  collapsed:: true
		- Protocol for securing DNS traffic, verifies DNS data integrity and origin
		- Protects against Man in the Middle (MitM) attacks
		- Route53 supports both DNSSEC for Domain Registration and Signing
		- **It only works with Public Hosted Zones**
	- **Route53 with third Registrar**
	  collapsed:: true
		- You can buy the domain out of AWS and use Route53 as the DNS provider
		- Update the NS records on the third party Registrar
	- **Health Checks**
	  collapsed:: true
		- HTTP Health Checks are only for public resources
		- Health checks -> Automated DNS Fail-over
		  collapsed:: true
			- Monitor an endpoint
			  collapsed:: true
				- App, server, other AWS resource
				- About 15 global health checkers will check the endpoint health
				- Health checks pass only when the endpoint responds with the 2xx or 3xx status codes
					- Can be setup to pass/fail based on the text in the first 5120 of the response
			- Monitor other health checks
			  collapsed:: true
				- **Calculated Health Checks**
					- Combine the results of multiple Health Checks into a single Health Check
					- You can use OR, AND, or NOT
					- Can monitor up to 256 child Health Chekcs
					- Specify how many of the health checks need to pass to make the parent pass
					- **Use case**: perform maintenance to your website without causing all health checks to fail
			- Monitor CloudWatch Alarms
			  collapsed:: true
				- Helpful for private resources
				- Route53 health checkers are outside the VPC, so they cannot access private endpoints (private VPC or on-prem resource)
				- You can create a CloudWatch Metric and associate a CloudWatch Alarm, then create a Health check that checks the alarm itself
	- ## Solution Architecture: RDS multi-region fail-over #compute #rds #route53 #sa
	  collapsed:: true
		- Option 1: Use an EC2 instance to public an endpoint to monitoring it with a health check
		- Option 2: create a CloudWatch Alarm. Then create a Health check that checks the alarm itself
		- RDS -> CloudWatch Alarm -> Health check -> CloudWatch Alarm -> CloudWatch Event / SNS topic -> Lambda Function -> Update Route53 DNS records + Promote RDS Read Replicas to writer
	- **Hybrid DNS**
	  collapsed:: true
		- By default, Route 53 Resolver automatically answers DNS queries for:
		  collapsed:: true
			- Local domain names for EC2 instances
			- Records in Private Hosted Zones
			- Records in public Name Servers
		- Hybrid DNS resolves DNS queries between VPC (Route53 Resolver) and your networks (other DNS Resolvers)
		  collapsed:: true
			- Networks can be:
				- VPC itself / Peered VPC
				- On-prem network (connected through Direct Connect or AWS VPN)
		- **Resolver Endpoints**
		  collapsed:: true
			- Associated with one or more VPCs in the same AWS Region
			- Create in two AZs for high availability
			- Each endpoint supports 10000 queries per second per IP address
			- *Inbound Endpoint*
				- DNS resolvers on your network can forward DNS queries to Route53 Resolver
				- Allows your DNS resolvers to resolve domain names for AWS resources and records in Route53 Private Hosted Zones
				- On-prem -> AWS
					- On-prem route table that forward DNS traffic to the resolver inbound endpoint to check Route53 resolver
			- *Outbound Endpoint*
				- Route53 resolver conditionally forwards DNS queries to your DNS resolvers
				- Use resolver rules to forward DNS queries to your DNS resolvers
				- AWS -> On-prem
					- Forward rule to redirect traffic to the on-prem DNS  resolvers
		- **Resolver rules**
		  collapsed:: true
			- Control which DNS queries are forwarded to DNS resolvers on your network
			- If multiple rules matched, Route53 resolver chooses the most specific match
			- Resolver rules can be shared across accounts using **AWS RAM**
				- Manage them centrally in on account
				- Send DNS queries from multiple VPC to the target IP defined in the rule
			- **Conditional forwarding rules (forwarding rules)**
				- Forward DNS queries for a specified domain and all its subdomains **to target IP addresses**
			- **System rules**
				- Selectively overriding the behaviour defined in forwarding rules
			- **Auto-defined system rules**
				- Defines how DNS queries the for selected domains are resolved
- # Solution Architecture Comaprisons #sa
  collapsed:: true
	- Web application and application layer in general
	- **EC2 on its own with Elastic IP**
	  collapsed:: true
		- Fail-over resides on a *standby instance*
			- Move EIP in case of Disaster Recovery
		- **Benefits**
			- Quick fail-over
			- Cheap
			- Does not scale
			- The client should not see the change happen
			- Helpful if the client needs to resolve static public IP address
	- **EC2 with Route53**
	  collapsed:: true
		- Stateless web app - scaling horizontally
		- DNS-based load balancing
			- Ability to use multiple instances
			- Route53 TTL implies client may get outdated information
			- Clients **MUST** have logic to deal with hostname resolution failures
			- Adding an instance may not receive full traffic right away due to DNS TTL
	- **ALB + ASG**
	  collapsed:: true
		- Classic architecture
			- Scales well
			- Time to scale is slow - AMI can help
		- New instances are in service right away
		- Users are not sent to instances that are out-of-service
		- ALB is elastic but cannot handle sudden, huge peak of demand (pre-warm)
		- CloudWatch used for scaling
		- Cross-Zone balancing for even traffic distribution
		- Could lose a few request if instances are overloaded
		- **Target utilization for scalability should be between 40% and 70%**
	- **ALB + ECS on EC2 (backed by ASg)**
	  collapsed:: true
		- Same properties as ALB + ASG
		- Application is run on Docker
		- Allows to have dynamic port mappings
		- Tough to orchestrate ECS service auto-scaling + ASG auto-scaling
	- **ALB + ECS on Fargate**
	  collapsed:: true
		- Serverless, no infrastructure to manage
		- Application is run on Docker
		- Service Auto Scaling is easy
		- Time to be in-service is quick
		- Still limited by the ALB in case of sudden peaks
		- "Serverless" app tier, "managed" load balancer
	- **ALB + Lambda**
	  collapsed:: true
		- Limited to Lambda's runtimes
		- Seamless scaling thanks to Lambda (1000 concurrent executions)
		- Simple way to expose Lambda functions as HTTP/S
		- Can combine with WAF
		- Good for hybrid microservices
			- Use ECS for some request, and Lambda for others
	- **API Gateway + Lambda**
	  collapsed:: true
		- Pay per request, seamless scaling, fully serverless
		- Soft limits: 10000/s API Gateway, 1000 concurrent Lambda executions
		- API gateway features -> authentication, rate limits, caching, etc.
		- *Lambda cold start* time may increase latency for some requests
		- Fully integrated with X-Ray
	- **API Gateway + AWS Service (as a proxy)**
	  collapsed:: true
		- Integrate AWS service directly instead of adding a intermediate Lambda
		- Lower latency, cheaper
		- Expose AWS APIs securely through API gateway
		- SQS, SNS, Step Functions
	- **API Gateway + HTTP backend (ex: ALB)**
	  collapsed:: true
		- Use API Gateway features on top of custom HTTP backend
			- Authentication, rate control, API keys, caching...
		- Can connect to on-prem service, ALB or third party HTTP service